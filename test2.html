<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div style="width: 100%;height:100vh;">
        <!-- <span>test</span> -->
        <!-- <div>test</div> -->
        <div></div>
    </div>
</body>
<!-- 闭包 -->
<!-- <script>
    var life = 100;
    const gua = 200;

    // const foo = (A, B) => {
    //     for (let key in B) {
    //         console.log(key)
    //         console.log(B[key])
    //         A[key] = B[key]
    //     }
    //     console.log(A)
    //         // console.log(Object.assign(A, B));
    //         // console.log(A.concat(B))
    // }
    // foo({
    //     a: 1,
    //     c: 3,
    //     d: 4
    // }, {
    //     b: 2
    // });
    // // foo([1, 2, 3, 4], [5])
    const foo = (root, tagName) => {
            if (tagName != null) {
                let res = document.getElementsByTagName(tagName);
                console.log(res)
                return res.length;
            } else {
                let res = []
                for (let i of document.body.children) {
                    console.log(i.children)
                    res.push(i.localName)
                }
                return res
            }

        }
        // console.log(foo(document, 'div'));
        // console.log(foo(document));
        // console.log(document.body.childNodes)
        // var lifefunc = function() {
        //     var lifee = 200;

    //     function a() {
    //         return lifee;
    //     }
    // }
    // console.log(lifefunc.a())

    // // //lifefunc是函数的时候
    // function lifefunc() {
    //     var lifee = 200;

    //     function a() {
    //         return lifee;
    //     }
    //     return a();
    // }
    // console.log(lifefunc())
    //     // lifefunc是变量的时候
    // var p = {
    //     life: 200,
    //     a: function() {
    //         return life;
    //     }
    // }
    // console.log(p)

    // // lifefunc是这样子的话
    // var lifefunc = function() {
    //     var lifee = 200;
    //     // var del = function() {
    //     //     lifee--;
    //     // }
    //     return 
    // }
    // console.log(lifefunc())
    // lifefunc.del
    // console.log(lifefunc())

    // 保密的一个形式
    var lifefunc = (function() {
        var lifee = 200;
        return {
            add() {
                lifee++;
                return lifee;
            },
            del() {
                lifee--;
                return lifee;
            },
            get() {
                return lifee;
            }
        }
    })();
    console.log(lifefunc)
    console.log(lifefunc.add())
    console.log(lifefunc.add())
    console.log(lifefunc.add())
    console.log(window)
</script>-->
<!-- 三羊变色问题 -->
<!--  <script>
    function funcolor(arr) {
        arr.sort((a, b) => {
            return b - a
        })
        console.log(arr)
        for (let i = 0; i < arr.length - 1; i++) {
            let temp = [...arr]
            while (temp[i] > 0) {
                if (temp[0] == temp[1] || temp[0] == temp[2] || temp[1] == temp[2]) {
                    console.log(temp)
                    return true;
                }
                temp[i] -= 2;
                if (i == 0) {
                    temp[1]++;
                    temp[2]++;
                } else if (i == 1) {
                    temp[0]++;
                    temp[2]++;
                }
            }
        }
        return false;
    }
    console.log(funcolor([3, 6, 7]))
</script> -->
<!-- 例题 -->
<!-- <script>
    var a = function() {
        this.b = 3;
    }
    var c = new a();
    a.prototype.b = 9;
    var b = 7;
    a();
    console.log(b);
    console.log(c.b);
</script> -->
<!-- vue的双向绑定 -->
<!-- <script>
    var obj = {};
    Object.defineProperty(obj, 'name', {
        writable: "", //是否可以修改
        configurable: "", //是否可以删除
        enumerable: "", //是否可以枚举
        value: "", //值
        get: function() {
            console.log("get方法")
        },
        set: function() {
            console.log("set方法")
        }
    })
    obj.name = 'test';
    var val = obj.name;

    let obj = {
        name: 'test',
        age: 19,
    }
    let handler = {
        get() {
            console.log("get")
            console.log(arguments)
        },
        set() {
            console.log('set')
        }
    }
    let proxy = new Proxy(obj, handler) 
    proxy.name = 'test2'
    proxy.age = 18
</script>-->
<!-- 版本号排序 -->
<!-- <script>
    // 选择排序法
    const chooseSort = arr => {
            for (let i = 0; i < arr.length; i++) {
                let minindex = i;
                for (let j = i + 1; j < arr.length; j++) {
                    if (arr[j] < arr[minindex]) {
                        minindex = j;
                    }
                }
                [arr[i], arr[minindex]] = [arr[minindex], arr[i]]
            }
            return arr;
        }
        //将if里面的内容替换
        //最终代码
    const versionsort = version => {
        const temp = version.map(v => v.split('.'));
        //变成[[1,45,0],[1,5],[1,6],[3,3,3,3,3,3]]
        //接下来是选择排序
        for (let i = 0; i < temp.length; i++) {
            let minindex = i;
            for (let j = i; j < temp.length; j++) {
                for (let k = 0; k < temp[j].length; k++) {
                    const current = +temp[j][k],
                        min = +temp[minindex][k];
                    if (current < min) {
                        minindex = j;
                    }
                    //只要不等,就立刻结束最内层for循环
                    if (current !== min) {
                        break;
                    }
                }
            }
            [temp[i], temp[minindex]] = [temp[minindex], temp[i]];
        }
        return temp.map(v => v.join('.'))
    }
    console.log(versionsort(['1.45.0', '1.5', '6', '3.3.3.3.3.3.3']))

    // 第二种解法sort
    function rule(str1, str2) {
        var arr1 = str1.split('.'), //去除'.'，将剩下的数字转换为数组
            arr2 = str2.split('.'),
            minLen = Math.min(arr1.length, arr2.length), //取出两个数组中的最小程度
            maxLen = Math.max(arr1.length, arr2.length); //最大长度
        //以最短的数组为基础进行遍历
        for (let i = 0; i < minLen; i++) {
            //这里需要转换后才进行比较，否则会出现'10'<'7'的情况
            if (parseInt(arr1[i]) > parseInt(arr2[i])) {
                return 1; //返回一个大于0的数，表示前者的index比后者的index大
            } else if (parseInt(arr1[i]) < parseInt(arr2[i])) {
                return -1; //返回一个小于0的数，表示前者的index比后者的index小
            }
            //因为不只进行一次计较，所以这里不对相等的两个数进行处理，否则有可能第一次比较就返回，不符合要求
            //这个是为了区分'4.8'和'4.8.0'的情况
            //在前面的比较都相同的情况下，则比较长度
            //位数多的index大
            if (i + 1 == minLen) {
                if (arr1.length > arr2.length) {
                    return 1;
                } else {
                    return -1;
                }
            }
        }
    }
    console.log(['1.45.0', '1.5', '6', '3.3.3.3.3.3.3'].sort(rule))
</script> -->

<!-- 闭包 -->
<!-- <script>
    function a() {
        let flag = 2;

        function fa() {
            console.log(flag);
        }
        return fa();
    }
    a();

    function a() {
        if (true) {
            let b = 2;
        }
        console.log(b)
    }
    a();
</script> -->
<!-- 二叉树 -->
<script>
    // 路径总和返回true||false
    function hasPathSum(root, sum) {
        if (root == null) return false;
        if (root.left == null && root.right == null) {
            return sum = root.val == 0
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)
    }
    // 路径总和返回数组列表
    function pathSum(root, sum) {
        let res = [];
        let huisu = function(root, sum, arr) {
            if (root === null) return;
            arr.push(root.val);
            if (root.left === null && root.right === null && root.val === sum) {
                res.push([...arr])
            }
            huisu(root.left, sum - root.val, arr);
            huisu(root.right, sum - root.val, arr);
            // 回溯，要把arrpop
            arr.pop();
        }
        huisu(root, sum, []);
        return res;
    }
</script>
<!-- 单链表 -->
<script>
    function ListNode(val) {
        this.val = val;
        this.next = null;
    }
    let head = new ListNode('0')
        // 尾插
        //head->1->2->3,要插入4的话，是head->1->2->3->4
    let add = function(head) {
            let first = new ListNode('1')
            let temp = head;
            while (temp.next != null) {
                temp = temp.next;
            }
            temp.next = first;
            first.next = null;
        }
        //头插
        //head->1->2->3,插入4,head->4->1->2->3
    let add2 = function(head) {
        let second = new ListNode('2')
        second.next = head.next;
        head.next = second;
    }
</script>
<!-- 二叉树一条和为sum的路径 -->
<script>
    function hasSum(root, sum) {
        //递归
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum - root.val == 0
        }
        return hasSum(root.left, sum - root.val) || hasSum(root.right, sum - root.val)
    }
</script>
<!-- 柯里化sum(2)(3)=sum(2,3) -->
<script>
    // function sum() {
    //     var num = arguments[0];
    //     if (arguments.length === 1) {
    //         return function(sec) {
    //             console.log(sec)
    //             return num + sec;
    //         }
    //     } else {
    //         var num = 0;
    //         for (let i = 0; i < arguments.length; i++) {
    //             num = num + arguments[i];
    //         }
    //         return num;
    //     }
    // }
    // console.log(sum(2, 3));
    // console.log(sum(2)(3));
</script>
<!-- <script>
    function sum(...args) {
        if ([...args].length == 1) {
            let sum2 = [...args][0];
            var suum = function(y) {
                sum2 += y;
                return suum;
            }
            suum.valueOf = function() {
                return sum2;
            }
            suum.toString = function() {
                return sum2;
            }
            return suum;
        } else {
            let sum1 = 0;
            for (var i = 0; i < [...args].length; i++) {
                sum1 += [...args][i];
            }
            return sum1
        }
    }
    console.log(sum()); // 0
    console.log(sum(2, 3, 4)); // 9
    console.log(sum(2)(3)(4)) //9
</script> -->
<!-- 判断两个对象是否相同 -->
<!-- <script>
    function isEqual(obj1, obj2) {
        let o1 = obj1 instanceof Object;
        let o2 = obj2 instanceof Object;
        //如果不是对象或数组，直接判断数据是否相等,同样适用于undefined，null
        if (!o1 || !o2) {
            return obj1 === obj2
        }
        //判断对象或者数组的长度，若不同则返回false
        if (Object.keys(obj1).length != Object.keys(obj2).length) {
            return false;
        }
        //判断是否同为对象或者数组，若不同则返回false
        if (Object.prototype.toString.call(obj1) != Object.prototype.toString.call(obj2)) {
            return false;
        }
        //obj1，obj2 可能是对象 或是 数组
        //注意，for循环中只能返回false，则某一项相同返回true，则不进行后面的判断
        //只能return false ，不能  return obj1[key].toString() == obj2[key].toString();
        for (let key in obj1) {
            let typeKey1 = Object.prototype.toString.call(obj1[key]);
            let typeKey2 = Object.prototype.toString.call(obj2[key]);
            //二者类型不同，返回false
            if (typeKey1 != typeKey2) {
                return false;
            }
            //如果是对象，递归二次对比
            if (typeKey1 == '[object Object]') {
                //如果是对象，递归二次对比
                if (!isEqual(obj1[key], obj2[key])) {
                    return false;
                }
            } else if (typeKey1 == '[object Array]') {
                //如果是数组，则转为字符串对比
                if (obj1[key].toString() != obj2[key].toString()) {
                    return false;
                }
            } else if (obj1[key] != obj2[key]) {
                //如果是字符串或者数字，直接对比值
                return false;
            }
        }
        return true;
    }
</script> -->
<!-- repeat -->
<!-- <script>
    function repeat(func, times, wait) {
        return function(str) {
            for (let i = 0; i < times; i++) {
                setTimeout(func(str), wait);
            }
        }
    }
    var repeatfun = repeat(console.log, 4, 3000);
    repeatfun('helloworld')
</script> -->
<!-- resolve -->
<script>
</script>

<!-- 快排 -->
<script>
    function Insertion(arr) {
        let len = arr.length;
        let preIndex, current;
        for (let i = 1; i < len; i++) {
            preIndex = i - 1;
            current = arr[i];
            while (preIndex >= 0 && current < arr[preIndex]) {
                arr[preIndex + 1] = arr[preIndex]
                preIndex--;
            }
            arr[preIndex + 1] = current;
        }
        return arr;
    }
    var arr = [3, 5, 7, 8, 9, 33, 55, 77, 22, 44, 56]
    console.log(Insertion(arr))
</script>
<!-- bind手撕 -->
<script>
    function newBind(...args) {
        var that = this;
        var _this = arguments[0];
        let arr = [...args];
        arr.splice(0, 1);
        console.log(arr)
        return function() {
            return that.apply(_this, arr);
        }
    }
    console.log(newBind(this, 1, 2, 3, 4))
</script>

</html>